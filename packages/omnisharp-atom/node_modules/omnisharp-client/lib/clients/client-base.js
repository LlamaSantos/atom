var rx_1 = require("rx");
var lodash_1 = require("lodash");
var enums_1 = require("../enums");
var contexts_1 = require("./contexts");
var response_handling_1 = require("./response-handling");
var normalCommands = [
    'findimplementations', 'findsymbols', 'findusages',
    'gotodefinition', 'gotofile', 'gotoregion', 'typelookup',
    'navigateup', 'navigatedown', 'projects', 'project'
];
var priorityCommands = [
    'updatebuffer', 'changebuffer', 'filesChanged'
];
var undeferredCommands = normalCommands.concat(priorityCommands);
function flattenArguments(obj, prefix) {
    if (prefix === void 0) { prefix = ''; }
    var result = [];
    lodash_1.each(obj, function (value, key) {
        if (lodash_1.isObject(value)) {
            result.push.apply(result, flattenArguments(value, "" + (prefix ? prefix + ':' : '') + (key[0].toUpperCase() + key.substr(1))));
            return;
        }
        result.push("--" + (prefix ? prefix + ':' : '') + (key[0].toUpperCase() + key.substr(1)) + "=" + value);
    });
    return result;
}
var ClientBase = (function () {
    function ClientBase(_options) {
        var _this = this;
        if (_options === void 0) { _options = {}; }
        this._options = _options;
        this._requestStream = new rx_1.Subject();
        this._responseStream = new rx_1.Subject();
        this._errorStream = new rx_1.Subject();
        this._customEvents = new rx_1.Subject();
        this._uniqueId = lodash_1.uniqueId("client");
        this._eventWatchers = new Map();
        this._commandWatchers = new Map();
        this._disposable = new rx_1.CompositeDisposable();
        var driver = _options.driver || enums_1.Driver.Stdio;
        _options.additionalArguments = flattenArguments(_options.omnisharp || {});
        var driverFactory = require('../drivers/' + enums_1.Driver[driver].toLowerCase());
        this._driver = new driverFactory(_options);
        this._disposable.add(this._driver);
        this._disposable.add(this._requestStream);
        this._disposable.add(this._responseStream);
        this._disposable.add(this._errorStream);
        this._disposable.add(this._customEvents);
        this._enqueuedEvents = rx_1.Observable.merge(this._customEvents, this._driver.events)
            .map(function (event) {
            if (lodash_1.isObject(event.Body)) {
                Object.freeze(event.Body);
            }
            return Object.freeze(event);
        });
        this._enqueuedResponses = rx_1.Observable.merge(this._responseStream, this._driver.commands
            .map(function (packet) { return new contexts_1.ResponseContext(new contexts_1.RequestContext(_this._uniqueId, packet.Command, {}, {}, 'command'), packet.Body); }));
        this._lowestIndexValue = _options.oneBasedIndices ? 1 : 0;
        this._statusStream = rx_1.Observable.merge(this._requestStream, this._responseStream)
            .map(function () { return ({
            state: _this._driver.currentState,
            outgoingRequests: _this._driver.outstandingRequests,
            hasOutgoingRequests: _this._driver.outstandingRequests > 0
        }); })
            .map(Object.freeze)
            .distinctUntilChanged()
            .share();
        if (this._options.debug) {
            this._disposable.add(this._responseStream.subscribe(function (Context) {
                // log our complete response time
                _this._customEvents.onNext({
                    Event: "log",
                    Body: {
                        Message: "/" + Context.command + "  " + Context.responseTime + "ms (round trip)",
                        LogLevel: "INFORMATION"
                    },
                    Seq: -1,
                    Type: "log"
                });
            }));
        }
        this.setupRequestStreams();
        this.setupObservers();
    }
    ClientBase.fromClient = function (ctor, client) {
        var v1 = new ctor(client._options);
        v1._driver = client._driver;
        v1._requestStream = client._requestStream;
        v1._responseStream = client._responseStream;
        v1._statusStream = client._statusStream;
        v1._errorStream = client._errorStream;
        v1._customEvents = client._customEvents;
        v1._uniqueId = client._uniqueId;
        v1._disposable = client._disposable;
        v1.setupObservers();
        return v1;
    };
    Object.defineProperty(ClientBase.prototype, "uniqueId", {
        get: function () { return this._uniqueId; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "id", {
        get: function () { return this._driver.id; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "serverPath", {
        get: function () { return this._driver.serverPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "projectPath", {
        get: function () { return this._driver.projectPath; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "currentState", {
        get: function () { return this._driver.currentState; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "events", {
        get: function () { return this._enqueuedEvents; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "commands", {
        get: function () { return this._driver.commands; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "state", {
        get: function () { return this._driver.state; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "outstandingRequests", {
        get: function () { return this._driver.outstandingRequests; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "status", {
        get: function () { return this._statusStream; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "requests", {
        get: function () { return this._requestStream; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "responses", {
        get: function () { return this._enqueuedResponses; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientBase.prototype, "errors", {
        get: function () { return this._errorStream; },
        enumerable: true,
        configurable: true
    });
    ClientBase.prototype.dispose = function () {
        if (this._disposable.isDisposed)
            return;
        this.disconnect();
        this._disposable.dispose();
    };
    ClientBase.prototype.setupRequestStreams = function () {
        var _this = this;
        var priorityRequests = new rx_1.BehaviorSubject(0), priorityResponses = new rx_1.BehaviorSubject(0);
        var pauser = rx_1.Observable.combineLatest(priorityRequests, priorityResponses, function (requests, responses) {
            if (requests > 0 && responses === requests) {
                priorityRequests.onNext(0);
                priorityResponses.onNext(0);
                return true;
            }
            else if (requests > 0) {
                return false;
            }
            return true;
        })
            .startWith(true)
            .debounce(120);
        // These are operations that should wait until after
        // we have executed all the current priority commands
        var deferredQueue = this._requestStream
            .where(function (z) { return !lodash_1.some(undeferredCommands, function (x) { return x === z.command; }); })
            .pausableBuffered(pauser)
            .subscribe(function (request) { return _this.handleResult(request); });
        // We just pass these operations through as soon as possible
        var normalQueue = this._requestStream
            .where(function (z) { return lodash_1.some(normalCommands, function (x) { return x === z.command; }); })
            .subscribe(function (request) { return _this.handleResult(request); });
        // We must wait for these commands
        // And these commands must run in order.
        var priorityQueue = this._requestStream
            .where(function (z) { return lodash_1.some(priorityCommands, function (x) { return x === z.command; }); })
            .doOnNext(function () { return priorityRequests.onNext(priorityRequests.getValue() + 1); })
            .controlled();
        priorityQueue
            .map(function (request) { return _this.handleResult(request); })
            .subscribe(function (response) {
            response
                .subscribeOnCompleted(function () {
                priorityResponses.onNext(priorityResponses.getValue() + 1);
                priorityQueue.request(1);
            });
        });
        // We need to have a pending request to catch the first one coming in.
        priorityQueue.request(1);
    };
    ClientBase.prototype.handleResult = function (context) {
        var _this = this;
        var result = this._driver.request(context.command, context.request);
        result.subscribe(function (data) {
            _this._responseStream.onNext(new contexts_1.ResponseContext(context, data));
        }, function (error) {
            _this._errorStream.onNext(new contexts_1.CommandContext(context.command, error));
        });
        return result;
    };
    ClientBase.prototype.log = function (message, logLevel) {
        // log our complete response time
        this._customEvents.onNext({
            Event: "log",
            Body: {
                Message: message,
                LogLevel: logLevel ? logLevel.toUpperCase() : "INFORMATION"
            },
            Seq: -1,
            Type: "log"
        });
    };
    ClientBase.prototype.connect = function (_options) {
        // There is no return from error for this client
        if (this.currentState === enums_1.DriverState.Error)
            return;
        if (this.currentState === enums_1.DriverState.Connected || this.currentState === enums_1.DriverState.Connecting)
            return;
        if (_options && _options.omnisharp) {
            _options.additionalArguments = flattenArguments(_options.omnisharp || {});
        }
        var driver = this._options.driver;
        lodash_1.extend(this._options, _options || {});
        this._options.driver = driver;
        this._driver.connect(this._options);
    };
    ClientBase.prototype.disconnect = function () {
        this._driver.disconnect();
    };
    ClientBase.prototype.request = function (action, request, options) {
        var _this = this;
        if (!options)
            options = {};
        lodash_1.defaults(options, { oneBasedIndices: this._options.oneBasedIndices });
        // Handle disconnected requests
        if (this.currentState !== enums_1.DriverState.Connected && this.currentState !== enums_1.DriverState.Error) {
            var response = new rx_1.AsyncSubject();
            var sub = this.state.where(function (z) { return z === enums_1.DriverState.Connected; }).subscribe(function (z) {
                sub.dispose();
                _this.request(action, request, options).subscribe(function (z) { return response.onNext(z); });
            });
            return response;
        }
        var Context = new contexts_1.RequestContext(this._uniqueId, action, request, options);
        this._requestStream.onNext(Context);
        return Context.getResponse(this._responseStream);
    };
    ClientBase.prototype.setupObservers = function () {
        var _this = this;
        this._driver.events.subscribe(function (x) {
            if (_this._eventWatchers.has(x.Event))
                _this._eventWatchers.get(x.Event).onNext(x.Body);
        });
        this._enqueuedResponses.subscribe(function (x) {
            if (!x.silent && _this._commandWatchers.has(x.command))
                _this._commandWatchers.get(x.command).onNext(x);
        });
        this.projectAdded = this.watchEvent("ProjectAdded");
        this.projectChanged = this.watchEvent("ProjectChanged");
        this.projectRemoved = this.watchEvent("ProjectRemoved");
        this.error = this.watchEvent("ProjectRemoved");
        this.msBuildProjectDiagnostics = this.watchEvent("MsBuildProjectDiagnostics");
        this.packageRestoreStarted = this.watchEvent("PackageRestoreStarted");
        this.packageRestoreFinished = this.watchEvent("PackageRestoreFinished");
        this.unresolvedDependencies = this.watchEvent("UnresolvedDependencies");
    };
    ClientBase.prototype.watchEvent = function (event) {
        var subject = new rx_1.Subject();
        this._eventWatchers.set(event, subject);
        this._disposable.add(subject);
        return subject.asObservable().share();
    };
    ClientBase.prototype.watchCommand = function (command) {
        var subject = new rx_1.Subject();
        this._commandWatchers.set(command, subject);
        this._disposable.add(subject);
        return subject.asObservable().share();
    };
    ClientBase.serverLineNumbers = response_handling_1.serverLineNumbers;
    ClientBase.serverLineNumberArrays = response_handling_1.serverLineNumberArrays;
    return ClientBase;
})();
exports.ClientBase = ClientBase;
