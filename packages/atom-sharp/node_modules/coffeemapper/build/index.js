(function() {
  var Chains, Promise, baseProcessor, debug, isFunction, setValueHook, singleMap, uuid;

  Promise = require("bluebird");

  Chains = require("bluebird-chains");

  debug = require("debug")("coffeemapper:index");

  uuid = function() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r, v;
      r = Math.random() * 16 | 0;
      v = c === 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  };

  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }

  isFunction = function(functionToCheck) {
    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';
  };

  baseProcessor = {
    newItem: function() {
      return {};
    },
    setValue: function(item, key, value) {
      return item[key] = value;
    },
    getValue: function(item, key) {
      return item[key];
    }
  };

  setValueHook = function(key, data, map, src, proc, refid) {
    return new Promise(function(resolve, reject) {
      debug("" + refid + " promiseHook - rule " + key + " ");
      return map[key](src, function(value) {
        debug("" + refid + " setValue - " + key + ": " + value + " ");
        proc.setValue(data, key, value);
        return resolve();
      }, resolve);
    });
  };

  singleMap = function(src, map, proc, data, refid) {
    return new Promise(function(resolve, reject) {
      var inrefid, key, p;
      inrefid = uuid();
      debug("" + refid + ":" + inrefid + " singleMap - start ");
      if (proc == null) {
        proc = baseProcessor;
      }
      if (data == null) {
        data = proc.newItem();
      }
      p = new Chains;
      for (key in map) {
        p.push(setValueHook, [key, data, map, src, proc, inrefid]);
      }
      debug("" + refid + ":" + inrefid + " singleMap - starting chains concat ");
      return p.last(p).then(function() {
        debug("" + refid + ":" + inrefid + " singleMap - finish ", p.length);
        return resolve(data);
      }, reject);
    });
  };

  module.exports = function(src, map, proc, data) {
    if (proc == null) {
      proc = baseProcessor;
    }
    return new Promise(function(resolve, reject) {
      var p, refid, s, _i, _len;
      refid = uuid();
      debug("" + refid + " main - start");
      p = new Chains;
      if (Array.isArray(src)) {
        for (_i = 0, _len = src.length; _i < _len; _i++) {
          s = src[_i];
          p.push(singleMap, [s, map, proc, data, refid]);
        }
      } else {
        p.push(singleMap, [src, map, proc, data, refid]);
      }
      debug("" + refid + " main - processing maps", p.length);
      return p.collect(p).then(function(data) {
        debug("" + refid + " main - finish");
        return resolve(data);
      }, reject);
    });
  };

}).call(this);
